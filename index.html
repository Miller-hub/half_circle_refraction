<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>半圓透鏡折射 (平板優化版) | 尤達數理</title>
    <style>
        :root {
            --header-bg: #2d3748;
            --bg-color: #f7fafc;
            --card-bg: #ffffff;
            --primary-color: #3182ce;
            --primary-hover: #2c5282;
            --practice-color: #d69e2e;
            --practice-hover: #b7791f;
            --ghost-color: #805ad5;
            --ghost-hover: #6b46c1;
            --danger-color: #e53e3e;
            --text-main: #2d3748;
            --text-sub: #718096;
            --border-color: #e2e8f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Microsoft JhengHei", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        header {
            background-color: var(--header-bg);
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
            z-index: 10;
        }

        .brand {
            font-size: 1.4rem; /* Slightly larger text */
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .brand svg { width: 28px; height: 28px; fill: white; }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            flex-direction: row;
        }

        /* Canvas Area - High Contrast & Responsive Size */
        .canvas-area {
            flex: 1;
            background-color: #4a5568;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            position: relative;
            overflow: auto;
        }

        .canvas-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            padding: 0;
            position: relative;
            /* Tablet Optimization: Use vmin to fill screen */
            width: 95vmin; 
            max-width: 800px;
            aspect-ratio: 1/1;
            flex-shrink: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            display: block;
        }

        #simCanvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #drawCanvas { position: absolute; top: 0; left: 0; z-index: 2; touch-action: none; cursor: crosshair; pointer-events: none; } 

        /* Sidebar Controls */
        .sidebar {
            width: 400px; /* Slightly wider for easier touch */
            background: white;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: -2px 0 5px rgba(0,0,0,0.02);
            -webkit-overflow-scrolling: touch; /* Smooth scroll on iOS */
        }

        .sidebar-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding-bottom: 50px; /* Extra space at bottom */
        }

        /* Tablet/Mobile Breakpoint - Increased to catch tablets in portrait */
        @media (max-width: 1024px) {
            .main-container { flex-direction: column; overflow-y: auto; }
            body { height: auto; overflow: auto; }
            
            .canvas-area { 
                min-height: auto; 
                padding: 15px; 
                flex: none; /* Allow it to size naturally */
            }
            
            .sidebar { 
                width: 100%; 
                border-left: none; 
                border-top: 1px solid var(--border-color); 
                height: auto; 
                overflow-y: visible; 
                flex: none;
            }
        }

        /* UI Components - Enlarged for Touch */
        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-sub);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 8px;
        }
        .section-title svg { width: 20px; height: 20px; fill: var(--text-sub); }

        .control-block { background: white; margin-bottom: 10px; }

        label { display: block; font-size: 1rem; font-weight: 600; margin-bottom: 10px; color: var(--text-main); }

        /* Larger Sliders */
        input[type=range] {
            width: 100%; height: 12px; /* Thicker track */
            background: #e2e8f0; border-radius: 6px;
            outline: none; -webkit-appearance: none; margin: 15px 0;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 28px; height: 28px; /* Larger thumb */
            background: var(--primary-color); border-radius: 50%; cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:active { transform: scale(1.2); }

        /* Larger Inputs */
        input[type=number] {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            color: var(--primary-color);
            font-weight: bold;
            width: 70px;
            text-align: right;
            font-family: monospace;
        }
        input[type=number]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.2);
        }

        /* Larger Buttons */
        .btn {
            display: flex; align-items: center; justify-content: center; gap: 8px;
            width: 100%; padding: 14px; /* Taller buttons */
            border: none; border-radius: 8px;
            font-size: 1.1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; color: white;
        }
        .btn-primary { background-color: var(--primary-color); }
        .btn-practice { background-color: var(--practice-color); }
        .btn-ghost { background-color: var(--ghost-color); }
        .btn-ghost.active { box-shadow: inset 0 2px 5px rgba(0,0,0,0.2); background-color: var(--ghost-hover); }
        .btn-outline-danger {
            background: transparent; border: 2px solid var(--danger-color); color: var(--danger-color);
        }
        .btn-outline-danger:hover { background-color: #fff5f5; }

        .btn-reset {
            background: none;
            border: none;
            color: var(--text-sub);
            cursor: pointer;
            font-size: 1.5rem; /* Larger icon */
            padding: 5px 10px;
            transition: color 0.2s;
            line-height: 1;
        }
        .btn-reset:hover {
            color: var(--primary-color);
        }

        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; }
        
        /* Larger Toggle Switch */
        .toggle-switch { position: relative; display: inline-block; width: 54px; height: 30px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #cbd5e0; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(24px); }

        .data-table { width: 100%; font-size: 1rem; border-collapse: collapse; }
        .data-table td { padding: 10px 0; border-bottom: 1px dashed var(--border-color); }
        .data-table td:last-child { text-align: right; font-family: monospace; font-weight: bold; color: var(--primary-color); }

        .status-badge {
            font-size: 1rem; padding: 10px 15px; border-radius: 6px; text-align: center;
            margin-top: 12px; display: none; font-weight: bold;
        }
        .bg-practice { background: #fefcbf; color: #744210; border: 1px solid #f6e05e; }
        .bg-ghost { background: #faf5ff; color: #553c9a; border: 1px solid #d6bcfa; }
        .bg-danger { background: #fff5f5; color: #c53030; border: 1px solid #fc8181; }

        .color-row { display: flex; gap: 15px; margin-top: 10px; }
        .color-dot { width: 40px; height: 40px; border-radius: 50%; border: 3px solid #e2e8f0; cursor: pointer; transition: transform 0.1s; }
        .color-dot.active { transform: scale(1.15); border-color: var(--text-main); }

        .hint-tooltip {
            position: absolute; background: var(--danger-color); color: white; padding: 8px 14px;
            border-radius: 20px; font-size: 1rem; font-weight: bold;
            top: -45px; right: 0; pointer-events: none; animation: bounce 1.5s infinite; z-index: 20;
        }
        .hint-tooltip::after {
            content: ''; position: absolute; bottom: -6px; right: 20px;
            border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid var(--danger-color);
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        .fade-out { opacity: 0; transition: opacity 0.5s; }

        .switch-label { font-size: 1rem; font-weight: bold; color: var(--primary-color); }

        /* Checkbox Scaling */
        input[type=checkbox] { transform: scale(1.3); margin-right: 5px; }

    </style>
</head>
<body>

    <header>
        <div class="brand">
            <svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12H4A8,8 0 0,1 12,4Z" /></svg>
            半圓透鏡折射 | 尤達數理
        </div>
    </header>

    <div class="main-container">
        <!-- Canvas -->
        <div class="canvas-area">
            <div class="canvas-card">
                <canvas id="simCanvas" width="800" height="800"></canvas>
                <canvas id="drawCanvas" width="800" height="800"></canvas>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-content">
                
                <!-- Settings -->
                <div class="control-block">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24"><path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" /></svg>
                        實驗設定
                    </div>

                    <!-- Direction Toggle -->
                    <div class="toggle-row" style="background: #edf2f7; padding: 15px; border-radius: 8px;">
                        <span id="directionLabel" class="switch-label">空氣 → 玻璃</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggleDirection" checked onchange="toggleDirection()">
                            <span class="slider"></span>
                        </label>
                    </div>

                    <div style="position: relative;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <label style="margin:0;">入射光角度 (θi)</label>
                            <button class="btn-reset" onclick="resetAngle()" title="重置角度">↺</button>
                        </div>
                        <div id="hintBubble" class="hint-tooltip">拖曳這裡改變角度！</div>
                        <input type="range" id="angleSlider" min="-80" max="80" value="0" step="1">
                        <div style="text-align: right; color: var(--primary-color); font-weight: bold; display: flex; align-items: center; justify-content: flex-end; gap: 5px;">
                            <input type="number" id="angleInput" value="0" min="-80" max="80" step="1"> °
                        </div>
                    </div>

                    <div style="position: relative; margin-top: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <label style="margin:0;">入射光偏移 (Offset)</label>
                            <button class="btn-reset" onclick="resetOffset()" title="重置偏移">↺</button>
                        </div>
                        <input type="range" id="offsetSlider" min="-180" max="180" value="0" step="1">
                        <div style="text-align: right; color: var(--primary-color); font-weight: bold; display: flex; align-items: center; justify-content: flex-end; gap: 5px;">
                            <input type="number" id="offsetInput" value="0" min="-180" max="180" step="1"> px
                        </div>
                    </div>

                    <label style="margin-top:20px;">玻璃折射率 (n)</label>
                    <input type="range" id="nSlider" min="1.0" max="2.5" value="1.50" step="0.01">
                    <div style="text-align: right; color: var(--primary-color); font-weight: bold;">
                        n = <span id="nDisplay">1.50</span>
                    </div>

                    <hr style="border:0; border-top:1px dashed #e2e8f0; margin: 20px 0;">

                    <div class="toggle-row">
                        <label style="margin:0;">顯示法線</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggleNormal" checked onchange="updateDraw()">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Drawing -->
                <div class="control-block">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg>
                        繪圖板
                        <div style="flex:1"></div>
                        <button class="btn btn-outline-danger" onclick="undoDrawing()" style="width:auto; padding: 8px 16px; font-size: 0.9rem; margin-right: 8px;">↩ 復原</button>
                        <button class="btn btn-outline-danger" onclick="clearDrawing()" style="width:auto; padding: 8px 16px; font-size: 0.9rem;">清除</button>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div class="color-row">
                            <div class="color-dot active" style="background: #2d3748;" onclick="setColor('#2d3748', this)"></div>
                            <div class="color-dot" style="background: #e53e3e;" onclick="setColor('#e53e3e', this)"></div>
                            <div class="color-dot" style="background: #3182ce;" onclick="setColor('#3182ce', this)"></div>
                            <div class="color-dot" style="background: #38a169;" onclick="setColor('#38a169', this)"></div>
                        </div>
                        <div style="display: flex; gap: 15px;">
                            <label style="font-weight: normal; margin: 0; display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="checkLineMode" onchange="toggleLineMode()"> 直線模式
                            </label>
                            <label style="font-weight: normal; margin: 0; display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="checkDraw" onchange="toggleDraw()"> 啟用
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Comparison / Data -->
                <div class="control-block">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24"><path d="M13.5,8H12V13L16.28,15.54L17,14.33L13.5,12.25V8M13,3A9,9 0 0,0 4,12H1L4.96,16.03L9,12H6A7,7 0 0,1 13,5A7,7 0 0,1 20,12A7,7 0 0,1 13,19C11.07,19 9.32,18.21 8.06,16.94L6.64,18.36C8.27,20 10.5,21 13,21A9,9 0 0,0 22,12A9,9 0 0,0 13,3" /></svg>
                        數據
                    </div>
                    
                    <button class="btn btn-ghost" id="btnGhost" onclick="toggleGhost()">
                        <svg viewBox="0 0 24 24"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" /></svg>
                        鎖定殘影
                    </button>
                    <div id="statusGhost" class="status-badge bg-ghost">比較模式開啟</div>

                    <table class="data-table" style="margin-top: 15px;">
                        <tr>
                            <td>臨界角 (θc)</td>
                            <td id="valCritical">--</td>
                        </tr>
                        <tr>
                            <td>折射角 (θr)</td>
                            <td id="valRefract">--</td>
                        </tr>
                    </table>
                    
                    <div id="statusTIR" class="status-badge bg-danger">
                        ⚠️ 發生全反射 (TIR)
                    </div>
                </div>

                <!-- Practice Mode -->
                <div class="control-block">
                    <div class="section-title">
                        <svg viewBox="0 0 24 24"><path d="M19,3H14.82C14.4,1.84 13.3,1 12,1C10.7,1 9.6,1.84 9.18,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M12,3A1,1 0 0,1 13,4A1,1 0 0,1 12,5A1,1 0 0,1 11,4A1,1 0 0,1 12,3M19,19H5V5H19V19M12,17L7,12L8.41,10.59L12,14.17L17.59,8.59L19,10L12,17Z" /></svg>
                        練習模式
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-practice" id="btnPracticeHide" onclick="togglePractice(true)">
                            <svg viewBox="0 0 24 24"><path d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z" /></svg>
                            隱藏解答
                        </button>
                        <button class="btn btn-primary" id="btnPracticeShow" onclick="togglePractice(false)" style="display: none; background-color: #38a169;">
                            <svg viewBox="0 0 24 24"><path d="M12,9A3,3 0 0,1 15,12A3,3 0 0,1 12,15A3,3 0 0,1 9,12A3,3 0 0,1 12,9M12,4.5C17,4.5 21.27,7.61 23,12C21.27,16.39 17,19.5 12,19.5C7,19.5 2.73,16.39 1,12C2.73,7.61 7,4.5 12,4.5M3.18,12C4.83,15.36 8.24,17.5 12,17.5C15.76,17.5 19.17,15.36 20.82,12C19.17,8.64 15.76,6.5 12,6.5C8.24,6.5 4.83,8.64 3.18,12Z" /></svg>
                            顯示解答
                        </button>
                    </div>
                    <div id="statusPractice" class="status-badge bg-practice">
                        已隱藏折射光線，請繪製光路
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const drawCanvas = document.getElementById('drawCanvas');
        const dCtx = drawCanvas.getContext('2d');

        const width = 800;
        const height = 800;
        const cx = 400;
        const cy = 400;
        const R = 200; 

        let state = {
            n: 1.50,
            angle: 0,
            offset: 0,
            showNormal: true,
            direction: 'air_to_glass'
        };

        let ghostState = null;
        let isPractice = false;

        // Drawing
        let isDrawing = false;
        let isLineMode = false;
        let drawColor = '#2d3748';
        let lastPos = {x:0, y:0};
        let currentStrokeEnd = null; 
        let drawSnapshot = null;
        let undoStack = [];
        const MAX_UNDO = 20;

        function toRad(deg) { return deg * Math.PI / 180; }
        function toDeg(rad) { return rad * 180 / Math.PI; }
        function normalize(v) { const len = Math.sqrt(v.x*v.x + v.y*v.y); return {x:v.x/len, y:v.y/len}; }

        function refract(I, N, n1, n2) {
            const r = n1 / n2;
            let calcN = N;
            if (I.x * N.x + I.y * N.y > 0) calcN = { x: -N.x, y: -N.y };
            const c = -(I.x * calcN.x + I.y * calcN.y);
            const disc = 1 - r * r * (1 - c * c);
            if (disc < 0) return null;
            const scalar = r * c - Math.sqrt(disc);
            return { x: r * I.x + scalar * calcN.x, y: r * I.y + scalar * calcN.y };
        }

        function reflect(I, N) {
            let calcN = N;
            if (I.x * N.x + I.y * N.y > 0) calcN = { x: -N.x, y: -N.y };
            const dot = I.x * calcN.x + I.y * calcN.y;
            return { x: I.x - 2 * dot * calcN.x, y: I.y - 2 * dot * calcN.y };
        }

        function intersectFlat(pos, dir) {
            if (Math.abs(dir.y) < 1e-6) return null;
            const t = -pos.y / dir.y;
            if (t < 1e-4) return null; 
            const xHit = pos.x + t * dir.x;
            if (Math.abs(xHit) > R) return null; 
            return { t: t, x: xHit, y: 0, nx: 0, ny: -1, type: 'flat' }; 
        }

        function intersectArc(pos, dir) {
            const A = 1;
            const B = 2 * (pos.x * dir.x + pos.y * dir.y);
            const C = (pos.x * pos.x + pos.y * pos.y) - R * R;
            const disc = B*B - 4*A*C;
            if (disc < 0) return null;
            
            const t1 = (-B - Math.sqrt(disc)) / 2;
            const t2 = (-B + Math.sqrt(disc)) / 2;
            let t = null;
            if (t1 > 1e-4) t = t1; else if (t2 > 1e-4) t = t2; else return null;

            const xHit = pos.x + t * dir.x;
            const yHit = pos.y + t * dir.y;
            
            if (yHit < 0) {
                if (t === t1 && t2 > 1e-4) {
                    const yHit2 = pos.y + t2 * dir.y;
                    if (yHit2 >= 0) t = t2; else return null;
                } else return null;
            }
            
            const hx = pos.x + t*dir.x;
            const hy = pos.y + t*dir.y;
            const nLen = Math.sqrt(hx*hx + hy*hy);
            return { t: t, x: hx, y: hy, nx: hx/nLen, ny: hy/nLen, type: 'arc' };
        }

        function traceRay(startPos, startDir, fromGlass) {
            let path = [startPos];
            let normals = [];
            let hasTIR = false;
            let currPos = startPos;
            let currDir = startDir;
            let flatHitInfo = null; 

            let hit1 = null;
            let n1 = 1.0, n2 = 1.0;

            if (fromGlass) {
                hit1 = intersectArc(currPos, currDir);
                n1 = 1.0; n2 = state.n;
            } else {
                hit1 = intersectFlat(currPos, currDir);
                n1 = 1.0; n2 = state.n;
            }

            if (!hit1) {
                path.push({ x: currPos.x + currDir.x * 1000, y: currPos.y + currDir.y * 1000 });
                return { path, normals, hasTIR, flatHitInfo };
            }

            path.push({x: hit1.x, y: hit1.y});
            normals.push(hit1);
            
            if (hit1.type === 'flat') {
                let dot = currDir.x * hit1.nx + currDir.y * hit1.ny;
                let incAng = Math.acos(Math.min(1, Math.abs(dot)));
                flatHitInfo = { theta_i: incAng, theta_r: 0 }; 
            }

            let rVec1 = refract(currDir, {x: hit1.nx, y: hit1.ny}, n1, n2);
            if (!rVec1) { return { path, normals, hasTIR: true, flatHitInfo }; }
            
            rVec1 = normalize(rVec1);
            
            if (hit1.type === 'flat' && flatHitInfo) {
                let dotR = rVec1.x * hit1.nx + rVec1.y * hit1.ny;
                flatHitInfo.theta_r = Math.acos(Math.min(1, Math.abs(dotR)));
            }

            currDir = rVec1;
            currPos = {x: hit1.x, y: hit1.y};

            let hit2 = null;
            if (fromGlass) {
                hit2 = intersectFlat(currPos, currDir);
            } else {
                hit2 = intersectArc(currPos, currDir);
            }

            if (!hit2) {
                path.push({ x: currPos.x + currDir.x * 1000, y: currPos.y + currDir.y * 1000 });
                return { path, normals, hasTIR, flatHitInfo };
            }

            path.push({x: hit2.x, y: hit2.y});
            normals.push(hit2);

            if (hit2.type === 'flat') {
                let dot = currDir.x * hit2.nx + currDir.y * hit2.ny;
                let incAng = Math.acos(Math.min(1, Math.abs(dot)));
                flatHitInfo = { theta_i: incAng, theta_r: 0 };
            }

            let rVec2 = refract(currDir, {x: hit2.nx, y: hit2.ny}, n2, 1.0); 
            
            if (!rVec2) {
                hasTIR = true;
                let refDir = reflect(currDir, {x: hit2.nx, y: hit2.ny});
                refDir = normalize(refDir);
                path.push({ x: hit2.x + refDir.x * 400, y: hit2.y + refDir.y * 400 });
            } else {
                rVec2 = normalize(rVec2);
                if (hit2.type === 'flat' && flatHitInfo) {
                    let dotR = rVec2.x * hit2.nx + rVec2.y * hit2.ny;
                    flatHitInfo.theta_r = Math.acos(Math.min(1, Math.abs(dotR)));
                }
                path.push({ x: hit2.x + rVec2.x * 400, y: hit2.y + rVec2.y * 400 });
            }

            return { path, normals, hasTIR, flatHitInfo };
        }

        function calcSimulation(s) {
            const fromGlass = s.direction === 'glass_to_air';
            const theta_i = toRad(s.angle);
            const offset = s.offset;
            const yDir = fromGlass ? -1 : 1;
            const dir = { x: Math.sin(theta_i), y: yDir * Math.cos(theta_i) };
            const perp = { x: -dir.y, y: dir.x };
            const dist = 400;
            const origin = { x: -dir.x * dist + perp.x * offset, y: -dir.y * dist + perp.y * offset };

            const result = traceRay(origin, dir, fromGlass);
            
            let criticalAngle = null;
            if (s.n > 1.0) criticalAngle = Math.asin(1.0 / s.n);

            return {
                path: result.path,
                normals: result.normals,
                hasTIR: result.hasTIR,
                criticalAngle,
                flatData: result.flatHitInfo
            };
        }

        function drawArrowHead(ctx, x, y, dx, dy, color) {
            const angle = Math.atan2(dy, dx);
            const size = 12; 
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size/2.5);
            ctx.lineTo(-size, size/2.5);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
        }

        function renderScene(data, isGhost) {
            const opacity = isGhost ? 0.3 : 1.0;
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.translate(cx, cy);

            // Draw Block
            ctx.beginPath();
            ctx.arc(0, 0, R, 0, Math.PI); 
            ctx.closePath();
            if (!isGhost) {
                ctx.fillStyle = "rgba(49, 130, 206, 0.4)"; 
                ctx.fill();
            }
            ctx.strokeStyle = isGhost ? "#aaa" : "#2d3748";
            ctx.lineWidth = 4;
            if (isGhost) ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw Path
            if (data.path.length > 0) {
                const p0 = data.path[0];
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y); 
                
                for (let i = 0; i < data.path.length - 1; i++) {
                    const isPracticeActive = isPractice && !isGhost;
                    
                    if (isPracticeActive) {
                        // air_to_glass: keep 0,1. hide >= 1?
                        // segments: 0->1(inc), 1->2(glass), 2->3(exit)
                        // air_to_glass: keep air inc (seg 0). Hide seg 1, 2.
                        if (state.direction === 'air_to_glass' && i >= 1) continue;
                        // glass_to_air: keep source(0), glass(1). Hide exit(2).
                        if (state.direction === 'glass_to_air' && i >= 2) continue;
                    }

                    const pStart = data.path[i];
                    const pEnd = data.path[i+1];
                    
                    // Draw segment independently
                    // Need to move to start of each segment because we might skip
                    ctx.beginPath(); // Start new path for each segment
                    ctx.moveTo(pStart.x, pStart.y);
                    ctx.lineTo(pEnd.x, pEnd.y);
                    
                    const isLastSegment = (i === data.path.length - 2);
                    const pathColor = data.hasTIR && isLastSegment ? "#e53e3e" : (isLastSegment ? "#3182ce" : "#e53e3e");
                    
                    ctx.strokeStyle = isGhost ? "#e53e3e" : pathColor;
                    ctx.lineWidth = 5;
                    ctx.stroke();

                    // Arrow
                    const mx = (pStart.x + pEnd.x) / 2;
                    const my = (pStart.y + pEnd.y) / 2;
                    const dx = pEnd.x - pStart.x;
                    const dy = pEnd.y - pStart.y;
                    if (Math.abs(dx) + Math.abs(dy) > 10) {
                        drawArrowHead(ctx, mx, my, dx, dy, isGhost ? "#e53e3e" : pathColor);
                    }
                }
            }

            if (state.showNormal && !isGhost) {
                ctx.strokeStyle = "#000000"; 
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 2;
                data.normals.forEach((n, idx) => {
                    // Hide exit normal in practice mode
                    if (isPractice && idx === 1) return;
                    
                    const len = 40;
                    ctx.beginPath();
                    ctx.moveTo(n.x - n.nx * len, n.y - n.ny * len);
                    ctx.lineTo(n.x + n.nx * len, n.y + n.ny * len);
                    ctx.stroke();
                });
                ctx.setLineDash([]);
            }
            ctx.restore();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            if (ghostState) {
                const gData = calcSimulation(ghostState);
                renderScene(gData, true);
            }
            const activeData = calcSimulation(state);
            renderScene(activeData, false);

            document.getElementById('nDisplay').innerText = state.n.toFixed(2);
            
            if (document.activeElement.id !== 'angleInput') document.getElementById('angleInput').value = state.angle;
            if (document.activeElement.id !== 'offsetInput') document.getElementById('offsetInput').value = state.offset;
            
            const critEl = document.getElementById('valCritical');
            const tirBadge = document.getElementById('statusTIR');
            
            if (activeData.criticalAngle !== null) {
                critEl.innerText = toDeg(activeData.criticalAngle).toFixed(1) + "°";
            } else {
                critEl.innerText = "無 (N/A)";
            }
            
            const refractionEl = document.getElementById('valRefract');
            if (isPractice) {
                refractionEl.innerText = "???";
                tirBadge.style.display = 'none';
            } else {
                if (activeData.hasTIR) {
                    refractionEl.innerText = "---";
                    tirBadge.style.display = 'block';
                } else {
                    tirBadge.style.display = 'none';
                    if (activeData.flatData) {
                        refractionEl.innerText = toDeg(activeData.flatData.theta_r).toFixed(1) + "°";
                    } else {
                        refractionEl.innerText = "--";
                    }
                }
            }
        }

        // --- Interaction ---
        function updateAngle(val) {
            state.angle = parseInt(val);
            document.getElementById('angleSlider').value = state.angle;
            document.getElementById('angleInput').value = state.angle;
            const hint = document.getElementById('hintBubble');
            if(hint) hint.classList.add('fade-out');
            draw();
        }
        function updateOffset(val) {
            state.offset = parseInt(val);
            document.getElementById('offsetSlider').value = state.offset;
            document.getElementById('offsetInput').value = state.offset;
            draw();
        }

        document.getElementById('angleSlider').addEventListener('input', (e) => updateAngle(e.target.value));
        document.getElementById('angleInput').addEventListener('input', (e) => updateAngle(e.target.value));
        
        document.getElementById('offsetSlider').addEventListener('input', (e) => updateOffset(e.target.value));
        document.getElementById('offsetInput').addEventListener('input', (e) => updateOffset(e.target.value));

        document.getElementById('nSlider').addEventListener('input', (e) => {
            state.n = parseFloat(e.target.value);
            draw();
        });

        window.toggleDirection = function() {
            const isChecked = document.getElementById('toggleDirection').checked;
            state.direction = isChecked ? 'air_to_glass' : 'glass_to_air';
            document.getElementById('directionLabel').innerText = isChecked ? '空氣 → 玻璃' : '玻璃 → 空氣';
            if (ghostState) window.toggleGhost();
            draw();
        }

        window.updateDraw = function() {
            state.showNormal = document.getElementById('toggleNormal').checked;
            draw();
        }

        window.togglePractice = function(active) {
            isPractice = active;
            document.getElementById('btnPracticeHide').style.display = active ? 'none' : 'flex';
            document.getElementById('btnPracticeShow').style.display = active ? 'flex' : 'none';
            if(active) document.getElementById('statusPractice').style.display = 'block';
            else document.getElementById('statusPractice').style.display = 'none';
            draw();
        }

        window.toggleGhost = function() {
            if (ghostState) {
                ghostState = null;
                document.getElementById('btnGhost').classList.remove('active');
                document.getElementById('statusGhost').style.display = 'none';
            } else {
                ghostState = JSON.parse(JSON.stringify(state));
                document.getElementById('btnGhost').classList.add('active');
                document.getElementById('statusGhost').style.display = 'block';
            }
            draw();
        }

        window.resetAngle = function() { updateAngle(0); }
        window.resetOffset = function() { updateOffset(0); }

        window.setColor = function(c, el) {
            drawColor = c;
            document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            el.classList.add('active');
        }
        window.clearDrawing = function() { 
            saveState(); 
            dCtx.clearRect(0,0,width,height); 
        }
        window.toggleLineMode = function() { isLineMode = document.getElementById('checkLineMode').checked; }
        
        window.toggleDraw = function() {
            const enabled = document.getElementById('checkDraw').checked;
            drawCanvas.style.pointerEvents = enabled ? 'auto' : 'none';
        }

        // --- Undo Logic ---
        function saveState() {
            if (undoStack.length >= MAX_UNDO) undoStack.shift();
            undoStack.push(dCtx.getImageData(0, 0, width, height));
        }

        window.undoDrawing = function() {
            if (undoStack.length > 0) {
                const lastState = undoStack.pop();
                dCtx.putImageData(lastState, 0, 0);
            }
        }

        function getPos(e) {
            const r = drawCanvas.getBoundingClientRect();
            let cx = e.clientX, cy = e.clientY;
            if (e.touches && e.touches.length) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
            const sx = width / r.width; const sy = height / r.height;
            return { x: (cx - r.left) * sx, y: (cy - r.top) * sy };
        }

        function startStroke(e) {
            const enabled = document.getElementById('checkDraw').checked;
            if (!enabled) return;
            if(e.type === 'touchstart') e.preventDefault();
            
            saveState(); 
            isDrawing = true; lastPos = getPos(e);
            currentStrokeEnd = lastPos; 
            if (isLineMode) drawSnapshot = dCtx.getImageData(0, 0, width, height);
            else { dCtx.beginPath(); dCtx.moveTo(lastPos.x, lastPos.y); }
        }

        function moveStroke(e) {
            if (!isDrawing) return;
            if(e.type === 'touchmove') e.preventDefault();
            const p = getPos(e);
            currentStrokeEnd = p; 
            if (isLineMode) {
                dCtx.putImageData(drawSnapshot, 0, 0);
                dCtx.save(); dCtx.beginPath();
                const dx = p.x - lastPos.x; const dy = p.y - lastPos.y;
                if (Math.abs(dx)>1 || Math.abs(dy)>1) {
                    const len = Math.sqrt(dx*dx+dy*dy);
                    const nx = dx/len; const ny = dy/len;
                    dCtx.moveTo(lastPos.x - nx*2000, lastPos.y - ny*2000);
                    dCtx.lineTo(lastPos.x + nx*2000, lastPos.y + ny*2000);
                }
                dCtx.strokeStyle = drawColor; dCtx.lineWidth = 1; dCtx.setLineDash([5, 5]); dCtx.globalAlpha = 0.6; dCtx.stroke(); dCtx.restore();
                
                dCtx.beginPath(); dCtx.moveTo(lastPos.x, lastPos.y); dCtx.lineTo(p.x, p.y);
                dCtx.lineCap = 'round'; dCtx.lineJoin = 'round'; dCtx.lineWidth = 4;
                dCtx.strokeStyle = drawColor; dCtx.setLineDash([]); dCtx.stroke();
            } else {
                dCtx.lineCap = 'round'; dCtx.lineJoin = 'round'; dCtx.lineWidth = 4;
                dCtx.lineTo(p.x, p.y); dCtx.strokeStyle = drawColor; dCtx.stroke();
            }
        }

        function endStroke() {
            if (!isDrawing) return;
            
            if (isLineMode && drawSnapshot && currentStrokeEnd) {
                dCtx.putImageData(drawSnapshot, 0, 0);
                dCtx.beginPath();
                dCtx.moveTo(lastPos.x, lastPos.y);
                dCtx.lineTo(currentStrokeEnd.x, currentStrokeEnd.y);
                dCtx.lineCap = 'round';
                dCtx.lineJoin = 'round';
                dCtx.lineWidth = 4;
                dCtx.strokeStyle = drawColor;
                dCtx.setLineDash([]);
                dCtx.stroke();
            }
            
            isDrawing = false;
            currentStrokeEnd = null;
        }
        
        drawCanvas.addEventListener('mousedown', startStroke);
        drawCanvas.addEventListener('mousemove', moveStroke);
        window.addEventListener('mouseup', endStroke);
        drawCanvas.addEventListener('touchstart', startStroke, {passive: false});
        drawCanvas.addEventListener('touchmove', moveStroke, {passive: false});
        window.addEventListener('touchend', endStroke);

        // Initial setup
        draw();
        // Initialize pointer events based on default checkbox state (unchecked)
        toggleDraw();
    })();
    </script>
</body>
</html>